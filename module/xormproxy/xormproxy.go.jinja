//orm用于映射mysql
package xormproxy

import (
	"context"
	"errors"
	"fmt"
	"net/url"
	"strings"
	"time"

	log "github.com/Golang-Tools/loggerhelper"
	_ "github.com/mattn/go-sqlite3" //根据使用的driver填写
	"github.com/xormplus/xorm"
)

//ErrProxyAllreadySettedClient 代理已经设置过redis客户端对象
var ErrProxyAllreadySettedClient = errors.New("代理不能重复设置客户端对象")

//ErrUnSupportSchema 不支持的数据库类型
var ErrUnSupportSchema = errors.New("不支持的数据库类型")

//Callback redis操作的回调函数
type Callback func(cli xorm.EngineInterface) error

//xormProxy redis客户端的代理
type xormProxy struct {
	xorm.EngineInterface
	parallelcallback bool
	queryTimeout     time.Duration
	callBacks        []Callback
}

// New 创建一个新的数据库客户端代理
func New() *xormProxy {
	proxy := new(xormProxy)
	return proxy
}

// IsOk 检查代理是否已经可用
func (proxy *xormProxy) IsOk() bool {
	if proxy.EngineInterface == nil {
		return false
	}
	return true
}

//SetConnect 设置连接的客户端
//@params cli UniversalClient 满足redis.UniversalClient接口的对象的指针
func (proxy *xormProxy) SetConnect(cli *xorm.Engine, opts ...Option) error {
	if proxy.IsOk() {
		return ErrProxyAllreadySettedClient
	}

	proxy.EngineInterface = cli
	DefaultOption := &Options{
		ShowSQL: true,
	}
	for _, opt := range opts {
		opt.Apply(DefaultOption)
	}
	if DefaultOption.MaxIdle > 0 {
		proxy.EngineInterface.SetMaxIdleConns(DefaultOption.MaxIdle)
	}
	if DefaultOption.MaxOpenConns > 0 {
		proxy.EngineInterface.SetMaxOpenConns(DefaultOption.MaxOpenConns)
	}
	if DefaultOption.ShowSQL {
		proxy.EngineInterface.ShowSQL(true)
	}
	if DefaultOption.QueryTimeout > 0 {
		proxy.queryTimeout = time.Duration(DefaultOption.QueryTimeout) * time.Millisecond
	}

	if proxy.parallelcallback {
		for _, cb := range proxy.callBacks {
			go func(cb Callback) {
				err := cb(proxy.EngineInterface)
				if err != nil {
					log.Error("regist callback get error", log.Dict{"err": err})
				} else {
					log.Debug("regist callback done")
				}
			}(cb)
		}
	} else {
		for _, cb := range proxy.callBacks {
			err := cb(proxy.EngineInterface)
			if err != nil {
				log.Error("regist callback get error", log.Dict{"err": err})
			} else {
				log.Debug("regist callback done")
			}
		}
	}
	return nil
}

func make_engine_from_url(u string) (*xorm.Engine, error) {
	U, err := url.Parse(u)
	if err != nil {
		return nil, err
	}
	dataSourceName := strings.ReplaceAll(u, fmt.Sprintf("%s://", U.Scheme), "")
	switch U.Scheme {
	case "postgres":
		{
			return xorm.NewEngine("postgres", u)
		}
	case "mysql":
		{
			return xorm.NewEngine("mysql", dataSourceName)
		}
	case "sqlserver":
		{
			return xorm.NewEngine("mssql", u)
		}
	case "sqlite":
		{
			return xorm.NewEngine("sqlite3", dataSourceName)
		}
	default:
		{
			return nil, ErrUnSupportSchema
		}
	}
}

//InitFromURL 从URL条件初始化代理对象
func (proxy *xormProxy) InitFromURL(u string, opts ...Option) error {
	engine, err := make_engine_from_url(u)
	if err != nil {
		return err
	}
	proxy.parallelcallback = false
	proxy.SetConnect(engine, opts...)
	return nil
}

//InitFromURLParallelCallback 从URL条件初始化代理对象
func (proxy *xormProxy) InitFromURLParallelCallback(u string, opts ...Option) error {
	engine, err := make_engine_from_url(u)
	if err != nil {
		return err
	}
	proxy.parallelcallback = true
	proxy.SetConnect(engine, opts...)
	return nil
}

// Regist 注册回调函数,在init执行后执行回调函数
//如果对象已经设置了被代理客户端则无法再注册回调函数
func (proxy *xormProxy) Regist(cb Callback) error {
	if proxy.IsOk() {
		return ErrProxyAllreadySettedClient
	}
	proxy.callBacks = append(proxy.callBacks, cb)
	return nil
}

// NewCtx 根据注册的超时时间构造一个上下文
func (proxy *xormProxy) NewCtx() (ctx context.Context, cancel context.CancelFunc) {
	if proxy.queryTimeout > 0 {
		timeout := proxy.queryTimeout
		ctx, cancel = context.WithTimeout(context.Background(), timeout)
	} else {
		ctx, cancel = context.WithCancel(context.Background())
	}
	return
}

//DB 默认的xorm代理对象
var DB = New()
